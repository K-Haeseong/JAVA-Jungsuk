// default 메서드와 static 메서드
// 내부클래스의 종류, 특징, 선언

//	<default 메서드와 static 메서드>
// 	1. 인터페이스에 default 메서드, static메서드 추가 가능 (JDK 1.8부터)
//	=> 인터페이스의 원칙을 단순하게 하기 위해서 원래는 뺐었던 것이다. 
//
//	2. 인터페이스에 새로운 메서드(추상 메서드)를 추가하기 어려움
//	=> 원래 인터페이스에 새로운 메서드(추상 메서드)를 추가
//	=> 추가하면 기존 인터페이스를 구현했던 클래스들이 새로운 메서드를 구현해야 한다는 문제가 발생(多수정)
//
//	3. 디폴트 메서드는 인스턴스 메서드(인터페이스 규/원칙 위반) - 예외
//	=> 2번의 문제점을 해결하고자 디폴트 메서드(구현까지 해놓은 메서드)를 추가 할 수 있게 해줬다.
//	=> 인터페이스는 추상메서드만 갖게 해서 충돌을 피하게 했었는데 디폴트 메서드 추가로 충돌 다시 발생
//
//	4. 디폴트 메서드가 기존의 메서드와 충돌할 때의 해결책 (* 규칙 모르겠으면 그냥 직접 오버라이딩 하자!)
//	 1)  여러 인터페이스의 디폴트 메서드 간의 충돌
//	 => 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩 해야 한다.
//	 2)디폴트 메서드와 조상 클래스의 메서드 간의 충돌
//	 => 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.

class AAA {
	int i = 200;
	BBB b = new BBB();

// 내부 클래스로 넣기	
	class BBB {
		void method() {
			System.out.println("BBB클래스입니다."); // 객체 생성없이 바로 외부 클래스의 멤버 접근 가능
		}
	
	}
	
}

// 클래스가 따로 존재할 때는 이렇게 객체를 생성해서 사용해야함
//class BBB {
//	void method() {
//		AAA a = new AAA();
//		System.out.println(a.i);
//	}
//
//}

//class CCC {
//	BBB b = new BBB();
//}
// 내부클래스로 들어갔기 때문에 더이상 접근 불가

public class Ex07_40_44 {

	public static void main(String[] args) {
		
//		BBB b3 = new BBB();
//		b.method();
		
	}

}
